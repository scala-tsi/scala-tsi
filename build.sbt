import sbt.Keys.scalacOptions

val scala213 = "2.13.2"
val scala212 = "2.12.11"

lazy val commonSettings = Seq(
  organization := "nl.codestar",
  version := "0.2.0",
  scalaVersion := scala213,
  crossScalaVersions := Seq(scala212, scala213),
  compilerOptions
  //expandMacros, // Uncomment to view code generated by macro
)

/* Settings to publish to maven central */
lazy val publishSettings = Seq(
  publishMavenStyle := true,
  publishTo := Some(if (isSnapshot.value) Opts.resolver.sonatypeSnapshots else Opts.resolver.sonatypeStaging),
  credentials += (sys.env.get("MAVEN_CENTRAL_USER") match {
    case Some(user) => Credentials("Sonatype Nexus Repository Manager", "oss.sonatype.org", user, sys.env("MAVEN_CENTRAL_PASSWORD"))
    case None       => Credentials(Path.userHome / ".ivy2" / ".nl-codestar-maven-central-credentials")
  }),
  licenses := Seq("MIT" -> url("https://github.com/code-star/scala-tsi/blob/master/LICENSE")),
  homepage := Some(url("https://github.com/code-star/scala-tsi")),
  scmInfo := Some(ScmInfo(url("https://github.com/code-star/scala-tsi"), "scm:git@github.com:code-star/scala-tsi.git")),
  developers := List(
    Developer(
      id = "dhoepelman",
      name = "David Hoepelman",
      email = "992153+dhoepelman@users.noreply.github.com",
      url = url("https://github.com/dhoepelman")
    ),
    Developer(id = "donovan", name = "Donovan de Kuiper", email = "donovan.de.kuiper@ordina.nl", url = url("https://github.com/Hayena"))
  )
) ++
  // CI-only settings, enabled if $CI env variable is set to "true"
  sys.env
    .get("CI")
    .collect({
      case "true" =>
        Seq(
          usePgpKeyHex("6044257F427C2854A6F9A0C211A02377A6DD0E59"),
          pgpSecretRing := file(".circleci/circleci.key.asc"),
          pgpPublicRing := file(".circleci/circleci.pub.asc"),
          pgpPassphrase := sys.env.get("GPG_passphrase").map(_.toCharArray)
        )
    })
    .getOrElse(Seq())

lazy val compilerOptions = scalacOptions := Seq(
  "-Xsource:2.13",
  "-unchecked",
  "-feature",
  "-deprecation",
  "-Xlint",
  "-encoding",
  "UTF8",
  "-target:jvm-1.8",
  "-Ywarn-numeric-widen",
  "-Ywarn-value-discard",
  "-Ywarn-dead-code",
  "-Ywarn-unused:implicits",
  "-Ywarn-unused:imports",
  "-Ywarn-unused:locals",
  "-Ywarn-unused:params",
  "-Ywarn-unused:patvars",
  "-Ywarn-unused:privates",
  "-language:experimental.macros"
) ++ (CrossVersion.partialVersion(scalaVersion.value) match {
  case Some((2, 13)) =>
    Seq(
      "-Xfatal-warnings" // fatal warnings is possible now warnings can be supressed with 2.13.2's @nowarn
    )
  case Some((2, 12)) =>
    Seq(
      "-Yno-adapted-args",
      "-Xfuture",
      "-language:higherKinds"
    )
  case _ => throw new IllegalArgumentException(s"Unconfigured scala version ${scalaVersion.value}")
})

lazy val expandMacros = scalacOptions += "-Ymacro-debug-lite"

//
lazy val `scala-tsi-macros` = (project in file("macros"))
  .settings(
    commonSettings,
    name := "scala-tsi-macros",
    description := "Macros for scala-tsi",
    libraryDependencies += "org.scala-lang" % "scala-reflect" % scalaVersion.value,
    // Disable publishing
    publish := {},
    publishLocal := {},
    skip in publish := true
  )

lazy val `scala-tsi` = (project in file("."))
  .settings(commonSettings)
  .settings(publishSettings)
  .settings(
    name := "scala-tsi",
    description := "Generate Typescript interfaces from your scala classes",
    libraryDependencies ++= Seq(
      // To support @nowarn in 2.12
      "org.scala-lang.modules" %% "scala-collection-compat" % "2.1.6",
      // testing framework
      "org.scalatest" %% "scalatest" % "3.0.8" % "test"
    )
  )
  // Depend and include the macro project, instead of having to publish a separate macro project
  .dependsOn(`scala-tsi-macros` % "compile-internal, test-internal")
  .settings(
    // Add dependencies from the macro project
    libraryDependencies ++= (`scala-tsi-macros` / libraryDependencies).value,
    // include the macro classes and resources in the main jar
    mappings in (Compile, packageBin) ++= mappings
      .in(`scala-tsi-macros`, Compile, packageBin)
      .value,
    // include the macro sources in the main source jar
    mappings in (Compile, packageSrc) ++= mappings
      .in(`scala-tsi-macros`, Compile, packageSrc)
      .value
  )

lazy val `sbt-scala-tsi` = (project in file("plugin"))
  .enablePlugins(SbtTwirl, BuildInfoPlugin)
  .settings(commonSettings)
  .settings(publishSettings)
  .settings(
    name := "sbt-scala-tsi",
    description := "SBT plugin to generate Typescript interfaces from your scala classes as part of your build",
    sbtPlugin := true,
    buildInfoKeys := Seq[BuildInfoKey](version),
    buildInfoPackage := "sbt.info",
    // sbt 1 uses scala 2.12
    scalaVersion := "2.12.11",
    crossScalaVersions := Seq("2.12.11")
  )
